# **Experiment 4: Dockerfile for web app containerization**


## **This experiment has Four-Part**

### **Part 1: Foundational Containerization** 
**Goal:** Master basic Docker workflows for web applications
- **Lab 1:** Containerize Flask app manually (interactive container method)
- **Lab 2:** Containerize Node.js app manually (hands-on learning)
- **Lab 3:** Implement Dockerfile automation for both frameworks
- **Outcome:** Understand container lifecycle and basic Docker commands

### **Part 2: Build Optimization with .dockerignore** 
**Goal:** Improve build performance and security
- **Lab 1:** Create and test `.dockerignore` for Python/Flask projects
- **Lab 2:** Create and test `.dockerignore` for Node.js projects
- **Lab 3:** Compare build times with/without `.dockerignore`
- **Outcome:** Learn to exclude unnecessary files from Docker builds

### **Part 3: Advanced Multi-stage Builds** 
**Goal:** Create production-optimized, minimal Docker images
- **Lab 1:** Implement multi-stage builds for Flask application
- **Lab 2:** Implement multi-stage builds for Node.js application
- **Lab 3:** Compare image sizes and security aspects
- **Outcome:** Master professional-grade Dockerfile patterns

### **Part 4: Production-Ready Implementation** 
**Goal:** Apply industry best practices for production deployments
- **Lab 1:** Complete production Dockerfile for Flask with security features
- **Lab 2:** Complete production Dockerfile for Node.js with optimization
- **Lab 3:** Performance benchmarking and cleanup strategies
- **Outcome:** Ready-to-use production Docker configurations


---

## **Part 1: Flask Application**

### **Lab 1: Basic Flask Web App Structure**

#### **Step 1: Create Flask Application Files**
```bash
# Create project folder
mkdir flask-lab
cd flask-lab

# Create app file
touch app.py
touch requirements.txt
```

#### **Step 2: Flask Application Code**

**`app.py`:**
```python
from flask import Flask

# Create Flask app
app = Flask(__name__)

# Define a route
@app.route('/')
def hello():
    return "Hello from Flask App!"

# Health check route
@app.route('/health')
def health():
    return "OK"

# Run the app
if __name__ == '__main__':
    app.run(host='0.0.0.0', port=5000)
```

**`requirements.txt`:**
```
Flask==2.3.3
```

#### **Step 3: Run Flask App Normally (Without Docker)**
```bash
# Install Flask
pip install Flask

# Run the application
python app.py

# In another terminal, test it:
curl http://localhost:5000
# Output: Hello from Flask App!
```

---

### **Lab 2: Run Flask App with Docker (Manual Method)**

#### **Step 1: Start with Python Base Image**
```bash
# Download Python base image
docker pull python:3.9-slim

# Run interactive container
docker run -it --name flask-container python:3.9-slim /bin/bash
```

#### **Step 2: Inside Container - Manual Setup**
```bash
# Inside container terminal:
# 1. Install Flask
pip install Flask

# 2. Create app directory
mkdir /app
cd /app

# 3. Create app.py (copy your code manually)
echo "from flask import Flask
app = Flask(__name__)

@app.route('/')
def hello():
    return 'Hello from Flask in Docker!'

if __name__ == '__main__':
    app.run(host='0.0.0.0', port=5000)" > app.py

# 4. Run the app
python app.py

# 5. Press Ctrl+P then Ctrl+Q to detach
```

#### **Step 3: Save Container as Image**
```bash
# Open new terminal (outside container)
# Commit container to image
docker commit flask-container my-flask-app:v1

# Stop and remove container
docker stop flask-container
docker rm flask-container
```

#### **Step 4: Run from Saved Image**
```bash
# Run container from your image
docker run -d --name my-flask -p 5000:5000 my-flask-app:v1 python /app/app.py

# Test the app
curl http://localhost:5000
# Output: Hello from Flask in Docker!
```

**What Happened:**

1. We created a container manually
2. Installed dependencies inside
3. Created application files
4. Saved as reusable image
5. Ran container from that image

---

### **Lab 3: Flask App with Dockerfile (Better Method)**

#### **Step 1: Create Project Structure**
```bash
flask-docker-project/
├── app.py
├── requirements.txt
└── Dockerfile
```

#### **Step 2: Create Dockerfile**

**`Dockerfile` (Create this file):**

```dockerfile
# STEP 1: Choose base image
FROM python:3.9-slim

# STEP 2: Set working directory inside container
WORKDIR /app

# STEP 3: Copy requirements file
COPY requirements.txt .

# STEP 4: Install dependencies
RUN pip install -r requirements.txt

# STEP 5: Copy application code
COPY app.py .

# STEP 6: Expose port
EXPOSE 5000

# STEP 7: Command to run app
CMD ["python", "app.py"]
```

#### **Step 3: Build Docker Image**
```bash
# Build image from Dockerfile
docker build -t flask-app:latest .

# Check image created
docker images
```

**Command Breakdown:**
- `docker build`: Build command
- `-t flask-app:latest`: Tag/name the image
- `.`: Use current directory (where Dockerfile is)

#### **Step 4: Run Container**
```bash
# Run container from image
docker run -d --name flask-container -p 5000:5000 flask-app:latest

# Test
curl http://localhost:5000
```

#### **Step 5: Manage Container**
```bash
# See running containers
docker ps

# View logs
docker logs flask-container

# Stop container
docker stop flask-container

# Start again
docker start flask-container

# Remove container
docker rm flask-container
```

---

## **Part 2: Node.js Application**

### **Lab 1: Basic Node.js Web App Structure**

#### **Step 1: Create Node.js Application Files**
```bash
# Create project folder
mkdir node-lab
cd node-lab

# Create app file
touch app.js
touch package.json
```

#### **Step 2: Node.js Application Code**

**`app.js`:**
```javascript
const express = require('express');
const app = express();
const port = 3000;

// Define a route
app.get('/', (req, res) => {
    res.send('Hello from Node.js App!');
});

// Health check route
app.get('/health', (req, res) => {
    res.json({ status: 'healthy' });
});

// Start server
app.listen(port, () => {
    console.log(`Server running at http://localhost:${port}`);
});
```

**`package.json`:**
```json
{
  "name": "node-app",
  "version": "1.0.0",
  "main": "app.js",
  "dependencies": {
    "express": "^4.18.2"
  }
}
```

#### **Step 3: Run Node App Normally (Without Docker)**
```bash
# Install dependencies
npm install

# Run the application
node app.js

# In another terminal, test:
curl http://localhost:3000
# Output: Hello from Node.js App!
```

---

### **Lab 2: Run Node.js App with Docker (Manual Method)**

#### **Step 1: Start with Node Base Image**
```bash
# Download Node base image
docker pull node:18-alpine

# Run interactive container
docker run -it --name node-container node:18-alpine /bin/sh
```

#### **Step 2: Inside Container - Manual Setup**
```bash
# Inside container terminal:
# 1. Create app directory
mkdir /app
cd /app

# 2. Initialize npm
npm init -y

# 3. Install Express
npm install express

# 4. Create app.js (copy your code manually)
echo "const express = require('express');
const app = express();
const port = 3000;

app.get('/', (req, res) => {
    res.send('Hello from Node in Docker!');
});

app.listen(port, () => {
    console.log('Server running');
});" > app.js

# 5. Run the app
node app.js

# 6. Press Ctrl+P then Ctrl+Q to detach
```

#### **Step 3: Save Container as Image**
```bash
# In new terminal
docker commit node-container my-node-app:v1

# Clean up
docker stop node-container
docker rm node-container
```

#### **Step 4: Run from Saved Image**
```bash
# Run container from your image
docker run -d --name my-node -p 3000:3000 my-node-app:v1 node /app/app.js

# Test
curl http://localhost:3000
# Output: Hello from Node in Docker!
```

---

### **Lab 3: Node.js App with Dockerfile (Better Method)**

#### **Step 1: Create Project Structure**
```bash
node-docker-project/
├── app.js
├── package.json
└── Dockerfile
```

#### **Step 2: Create Dockerfile**

**`Dockerfile`:**

```dockerfile
# STEP 1: Choose base image
FROM node:18-alpine

# STEP 2: Set working directory
WORKDIR /app

# STEP 3: Copy package files
COPY package*.json ./

# STEP 4: Install dependencies
RUN npm install

# STEP 5: Copy application code
COPY app.js .

# STEP 6: Expose port
EXPOSE 3000

# STEP 7: Command to run app
CMD ["node", "app.js"]
```

#### **Step 3: Build and Run**
```bash
# Build image
docker build -t node-app:latest .

# Run container
docker run -d --name node-container -p 3000:3000 node-app:latest

# Test
curl http://localhost:3000
```

---

## **Comparison: Manual vs Dockerfile Approach**

### **Manual Method (Learning Purpose)**
```bash
# Pros: Good for understanding
# Cons: Not repeatable, time-consuming

docker run -it BASE_IMAGE
# Do everything manually inside
# Install dependencies
# Create files
# Save as image
```

### **Dockerfile Method (Real Projects)**
```bash
# Pros: Repeatable, automated, version-controlled
# Cons: Need to write Dockerfile

# 1. Write Dockerfile
# 2. Build image: docker build -t myapp .
# 3. Run container: docker run -p PORT:PORT myapp
```

---

## **Common Docker Commands Cheatsheet**

| Command | Purpose | Example |
|---------|---------|---------|
| `docker build` | Create image from Dockerfile | `docker build -t myapp .` |
| `docker run` | Run container from image | `docker run -p 3000:3000 myapp` |
| `docker ps` | List running containers | `docker ps` |
| `docker stop` | Stop container | `docker stop container-name` |
| `docker rm` | Remove container | `docker rm container-name` |
| `docker images` | List images | `docker images` |
| `docker rmi` | Remove image | `docker rmi image-name` |
| `docker logs` | View container logs | `docker logs container-name` |

---

## **Quick Practice Exercise**

### **Task 1: Modify Flask App**
1. Add new route `/about` that returns "About Page"
2. Update Dockerfile to install additional package `requests`
3. Rebuild and test

### **Task 2: Modify Node.js App**
1. Add new route `/api/data` that returns JSON
2. Change port to 8080 in both app.js and Dockerfile
3. Rebuild and test

### **Solution Hints:**
```bash
# For Flask:
# In requirements.txt add: requests==2.31.0
# Rebuild: docker build -t flask-app:v2 .
# Run: docker run -p 5000:5000 flask-app:v2

# For Node.js:
# In Dockerfile change: EXPOSE 8080
# Rebuild: docker build -t node-app:v2 .
# Run: docker run -p 8080:8080 node-app:v2
```

---

## **Key Takeaways**

1. **Dockerfile automates** what you do manually in container
2. **Three-step process** for any app:
   - Write Dockerfile
   - Build image: `docker build -t name .`
   - Run container: `docker run -p PORT:PORT name`
3. **Port mapping** is crucial: `-p HOST_PORT:CONTAINER_PORT`
4. **Always use** Dockerfile for real projects - it's repeatable and shareable

---

## **Cleanup**
```bash
# Stop and remove all containers
docker stop $(docker ps -aq)
docker rm $(docker ps -aq)

# Remove all images
docker rmi $(docker images -q)

# Remove unused data
docker system prune -a
```


---











## **Part 3: Advanced Docker Features**

### **Lab 1: Using .dockerignore for Better Builds**

#### **Step 1: Why .dockerignore is Important**
- Prevents unnecessary files from being copied into the Docker image
- Reduces image size
- Improves build performance
- Increases security by excluding sensitive files

#### **Step 2: Create .dockerignore Files**

**For Flask Project (`flask-docker-project/.dockerignore`):**
```
# Python specific
__pycache__/
*.py[cod]
*$py.class
*.so
.Python
env/
venv/
.env

# IDE files
.vscode/
.idea/
*.swp
*.swo

# Git
.git/
.gitignore

# OS files
.DS_Store
Thumbs.db

# Logs
*.log

# Test files
tests/
test_*.py

# Local development files
docker-compose.yml
.docker/
README.md
```

**For Node.js Project (`node-docker-project/.dockerignore`):**
```
# Dependencies
node_modules/
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# Environment variables
.env
.env.local
.env.production

# IDE files
.vscode/
.idea/
*.swp
*.swo

# Git
.git/
.gitignore

# OS files
.DS_Store
Thumbs.db

# Build files
dist/
build/
coverage/

# Test files
__tests__/
__mocks__/
```

#### **Step 3: Verify .dockerignore Works**
```bash
# Create a test file that should be ignored
echo "Sensitive data" > flask-docker-project/secrets.txt
echo "Temp file" > flask-docker-project/temp.pyc

# Build the image and check if files are excluded
docker build -t flask-app-test .
# The build context will skip secrets.txt and temp.pyc
```

---

### **Lab 2: Multi-stage Builds for Production Optimization**

#### **Why Multi-stage Builds?**
- Create smaller final images
- Separate build dependencies from runtime
- Improve security by removing build tools
- Reduce attack surface

#### **Step 1: Flask App with Multi-stage Build**

**Updated `Dockerfile` for Flask:**
```dockerfile
# STAGE 1: Builder stage
FROM python:3.9-slim AS builder

WORKDIR /app

# Install system dependencies if needed
RUN apt-get update && apt-get install -y \
    gcc \
    && rm -rf /var/lib/apt/lists/*

# Copy requirements first for better caching
COPY requirements.txt .

# Create virtual environment
RUN python -m venv /opt/venv
ENV PATH="/opt/venv/bin:$PATH"

# Install dependencies in virtual environment
RUN pip install --no-cache-dir -r requirements.txt


# STAGE 2: Runtime stage
FROM python:3.9-slim AS runtime

WORKDIR /app

# Copy virtual environment from builder
COPY --from=builder /opt/venv /opt/venv
ENV PATH="/opt/venv/bin:$PATH"

# Create non-root user for security
RUN groupadd -r flaskgroup && useradd -r -g flaskgroup flaskuser
RUN chown -R flaskuser:flaskgroup /app
USER flaskuser

# Copy application code
COPY --chown=flaskuser:flaskgroup app.py .

# Expose port
EXPOSE 5000

# Health check
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
    CMD curl -f http://localhost:5000/health || exit 1

# Run application
CMD ["python", "app.py"]
```

#### **Step 2: Node.js App with Multi-stage Build**

**Updated `Dockerfile` for Node.js:**
```dockerfile
# STAGE 1: Builder stage
FROM node:18-alpine AS builder

WORKDIR /app

# Copy package files
COPY package*.json ./

# Install all dependencies (including dev dependencies)
RUN npm ci --only=production


# STAGE 2: Runtime stage
FROM node:18-alpine AS runtime

WORKDIR /app

# Create non-root user
RUN addgroup -g 1001 -S nodegroup && \
    adduser -S nodeuser -u 1001 -G nodegroup

# Copy node_modules from builder stage
COPY --from=builder --chown=nodeuser:nodegroup /app/node_modules ./node_modules

# Copy application code
COPY --chown=nodeuser:nodegroup app.js ./
COPY --chown=nodeuser:nodegroup package.json ./

# Switch to non-root user
USER nodeuser

# Expose port
EXPOSE 3000

# Health check
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
    CMD curl -f http://localhost:3000/health || exit 1

# Run application
CMD ["node", "app.js"]
```

---

#### **Step 3: Build and Compare Image Sizes**
```bash
# Build Flask app with multi-stage
cd flask-docker-project
docker build -t flask-app-multi:latest .

# Build Flask app without multi-stage (for comparison)
docker build -f Dockerfile.single -t flask-app-single:latest .

# Compare sizes
docker images | grep flask-app

# Expected output:
# flask-app-multi    latest     ~150MB
# flask-app-single   latest     ~250MB

# Do the same for Node.js
cd node-docker-project
docker build -t node-app-multi:latest .
docker build -f Dockerfile.single -t node-app-single:latest .
docker images | grep node-app
```

---

## **Part 4: Complete Production-ready Examples**

### **Complete Flask Project Structure**
```
flask-docker-project/
├── .dockerignore
├── Dockerfile
├── requirements.txt
├── app.py
├── .env.example
└── README.md
```

**Production `Dockerfile` for Flask:**
```dockerfile
# Multi-stage Dockerfile for Flask Production

# === BUILDER STAGE ===
FROM python:3.9-slim AS builder

# Set environment variables
ENV PYTHONDONTWRITEBYTECODE=1
ENV PYTHONUNBUFFERED=1

WORKDIR /app

# Install system dependencies
RUN apt-get update && apt-get install -y \
    gcc \
    curl \
    && rm -rf /var/lib/apt/lists/*

# Copy requirements
COPY requirements.txt .

# Create and activate virtual environment
RUN python -m venv /opt/venv
ENV PATH="/opt/venv/bin:$PATH"

# Install Python dependencies
RUN pip install --no-cache-dir --upgrade pip && \
    pip install --no-cache-dir -r requirements.txt


# === RUNTIME STAGE ===
FROM python:3.9-slim AS runtime

# Set environment variables
ENV PYTHONDONTWRITEBYTECODE=1
ENV PYTHONUNBUFFERED=1
ENV PATH="/opt/venv/bin:$PATH"

WORKDIR /app

# Create non-root user
RUN groupadd -r appgroup && useradd -r -g appgroup appuser

# Copy virtual environment from builder
COPY --from=builder /opt/venv /opt/venv

# Copy application code
COPY --chown=appuser:appgroup . .

# Switch to non-root user
USER appuser

# Expose port
EXPOSE 5000

# Health check
HEALTHCHECK --interval=30s --timeout=10s --start-period=5s --retries=3 \
    CMD curl -f http://localhost:5000/health || exit 1

# Run application
CMD ["python", "app.py"]
```

---

### **Complete Node.js Project Structure**
```
node-docker-project/
├── .dockerignore
├── Dockerfile
├── package.json
├── app.js
├── .env.example
└── README.md
```

**Production `Dockerfile` for Node.js:**
```dockerfile
# Multi-stage Dockerfile for Node.js Production

# === BUILDER STAGE ===
FROM node:18-alpine AS builder

WORKDIR /app

# Copy package files
COPY package*.json ./

# Install dependencies
RUN npm ci --only=production --omit=dev


# === RUNTIME STAGE ===
FROM node:18-alpine AS runtime

# Set environment variables
ENV NODE_ENV=production
ENV PORT=3000

WORKDIR /app

# Create non-root user
RUN addgroup -g 1001 -S nodegroup && \
    adduser -S nodeuser -u 1001

# Copy dependencies from builder
COPY --from=builder --chown=nodeuser:nodegroup /app/node_modules ./node_modules

# Copy application files
COPY --chown=nodeuser:nodegroup . .

# Switch to non-root user
USER nodeuser

# Expose port
EXPOSE 3000

# Health check
HEALTHCHECK --interval=30s --timeout=10s --start-period=5s --retries=3 \
    CMD curl -f http://localhost:3000/health || exit 1

# Run application
CMD ["node", "app.js"]
```

---

## **Part 5: Build Optimization Techniques**

### **Layer Caching Strategy**
```dockerfile
# Good practice: Copy package files first to leverage Docker cache
COPY requirements.txt .  # or COPY package*.json ./
RUN pip install -r requirements.txt  # or RUN npm install

# Then copy application code
COPY . .
```

### **Using Docker BuildKit**
```bash
# Enable BuildKit for faster builds
export DOCKER_BUILDKIT=1
# or
DOCKER_BUILDKIT=1 docker build -t myapp .

# Build with progress output
docker build --progress=plain -t myapp .
```

---

## **Extended Practice Exercises**

### **Exercise 1: Advanced .dockerignore**
1. Create a `.dockerignore` that excludes:
   - All markdown files except README.md
   - All image files (.jpg, .png)
   - Configuration files for different environments (.env.dev, .env.staging)

### **Exercise 2: Multi-stage with Testing**
```dockerfile
# Add a test stage
FROM python:3.9-slim AS tester
COPY . .
RUN pip install pytest && pytest

# Then continue with builder and runtime stages
```

### **Exercise 3: Build Arguments**
```dockerfile
# Use build arguments for flexibility
ARG APP_VERSION=1.0.0
ARG NODE_ENV=production

ENV APP_VERSION=${APP_VERSION}
ENV NODE_ENV=${NODE_ENV}

# Build with arguments
# docker build --build-arg APP_VERSION=2.0.0 -t myapp .
```

---

## **Performance Comparison Table**

| Aspect | Single-stage | Multi-stage | Improvement |
|--------|--------------|-------------|-------------|
| Image Size | 250MB (Flask) | 150MB (Flask) | 40% smaller |
| Build Time | 2 minutes | 1.5 minutes | 25% faster |
| Security | All tools present | Only runtime tools | Much better |
| Layers | 10+ layers | Optimized layers | Better caching |

---

## **Updated Cheatsheet with Advanced Commands**

| Command | Purpose | Example |
|---------|---------|---------|
| `docker build --no-cache` | Build without cache | `docker build --no-cache -t app .` |
| `docker history` | Show image layers | `docker history image-name` |
| `docker image prune` | Remove unused images | `docker image prune -a` |
| `docker scan` | Security scan | `docker scan image-name` |
| `docker build --target` | Build specific stage | `docker build --target builder -t app .` |

---

## **Final Cleanup Commands**
```bash
# Remove all unused data (images, containers, volumes, networks)
docker system prune -a --volumes

# Remove specific images
docker rmi $(docker images -f "dangling=true" -q)

# Check disk usage
docker system df
```

---

## **Key Takeaways - Extended**

1. **`.dockerignore` is essential** for security and performance
2. **Multi-stage builds** create smaller, more secure production images
3. **Use non-root users** in containers for security
4. **Implement health checks** for better container management
5. **Leverage Docker cache** by copying dependency files first
6. **Production images should be minimal** - only include what's needed to run

