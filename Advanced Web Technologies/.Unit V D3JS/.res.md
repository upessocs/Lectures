### Part 1: D3.js Tutorial - Bringing Data to Life in the Browser

D3.js (Data-Driven Documents) is a powerful JavaScript library for manipulating documents based on data. It uses HTML, SVG, and CSS to create dynamic, interactive data visualizations.

#### Core Concept: Data Joins
The fundamental concept in D3 is the **data join**. It's the process of linking data points to visual elements (like circles in a scatter plot). D3 handles the enter, update, and exit states for these elements.

*   **Enter:** For new data points with no corresponding DOM element.
*   **Update:** For existing elements that are bound to data.
*   **Exit:** For existing DOM elements that no longer have a corresponding data point.
---
#### Tutorial: Creating a Simple Bar Chart

Let's build a basic bar chart step-by-step.

**1. Setup the HTML Boilerplate**
Create an `index.html` file.

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>D3.js Bar Chart Tutorial</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
</head>
<body>
    <svg id="chart"></svg>
    <script src="script.js"></script>
</body>
</html>
```
---
**2. Write the D3 JavaScript Code**
Create a `script.js` file.

```javascript
// 1. Define the dataset
const dataset = [30, 86, 150, 80, 200, 60, 120];

// 2. Set up dimensions and margins for the chart
const margin = { top: 20, right: 30, bottom: 40, left: 40 };
const width = 600 - margin.left - margin.right;
const height = 400 - margin.top - margin.bottom;

// 3. Select the SVG and set its viewBox for responsiveness
const svg = d3.select("#chart")
    .attr("viewBox", `0 0 600 400`); // Makes the chart scalable

// 4. Create a group element and apply margins
const g = svg.append("g")
    .attr("transform", `translate(${margin.left}, ${margin.top})`);

// 5. Create Scales
// xScale: Maps data indices to horizontal positions (Band scale for bars)
const xScale = d3.scaleBand()
    .domain(d3.range(dataset.length)) // [0, 1, 2, 3, 4, 5, 6]
    .range([0, width])
    .padding(0.1); // Space between bars

// yScale: Maps data values to vertical positions (Linear scale for heights)
const yScale = d3.scaleLinear()
    .domain([0, d3.max(dataset)]) // From 0 to the max value (200)
    .range([height, 0]); // Note: SVG y-coordinate is top-down, so we invert it

// 6. Draw the Bars (The ENTER Selection)
g.selectAll("rect")
    .data(dataset)
    .enter() // Get the elements-to-be-created
    .append("rect")
    .attr("x", (d, i) => xScale(i)) // Horizontal position based on index
    .attr("y", d => yScale(d))      // Vertical position based on data value
    .attr("width", xScale.bandwidth()) // Width of each band
    .attr("height", d => height - yScale(d)) // Height is total height minus y position
    .attr("fill", "steelblue");

// 7. Draw the Axes
// X-Axis (bottom)
g.append("g")
    .attr("transform", `translate(0, ${height})`)
    .call(d3.axisBottom(xScale).tickFormat(i => i + 1)); // Label bars as 1, 2, 3...

// Y-Axis (left)
g.append("g")
    .call(d3.axisLeft(yScale));
```
---
**Key D3 Concepts Demonstrated:**
*   **Selection:** `d3.select()` and `d3.selectAll()`.
*   **Data Binding:** `.data(dataset)`.
*   **Enter Selection:** `.enter().append("rect")` to create new elements for each data point.
*   **Scales:** `scaleBand()` for categorical/ordinal data, `scaleLinear()` for numerical data. They map from the **data domain** to the **visual range**.
*   **Axes:** The `d3.axisBottom()` and `d3.axisLeft()` functions generate ready-made axes based on your scales.

**Next Steps in D3:**
*   Add interactivity (e.g., tooltips on mouseover using `.on("mouseover", function)`).
*   Create different chart types (line charts, pie charts, scatter plots).
*   Work with real-world data (loading from a CSV/JSON file using `d3.csv()` or `d3.json()`).
*   Add animations and transitions (using `.transition().duration()`).

---

### Part 2: Advanced Database Systems Overview
---
#### 1. Overview of Object-Oriented Concepts in Databases
Object-Oriented Databases (OODBMS) were created to handle complex data relationships more naturally than Relational Databases (RDBMS).
*   **Objects:** Encapsulate both data (attributes) and behavior (methods).
*   **Classes:** Blueprints for creating objects.
*   **Inheritance:** A class can inherit attributes and methods from a parent class, promoting code reuse.
*   **Polymorphism:** The same operation can behave differently on different classes.
*   **Encapsulation:** Hiding the internal state of an object and requiring all interaction to be performed through an object's methods.
---
#### 2. Object Model of ODMG
The Object Data Management Group (ODMG) proposed a standard for OODBMS.
*   **Objective:** To provide portability for applications across compliant OODBMS, similar to how SQL provides portability across RDBMS.
*   **Key Components:**
    *   **Object Model:** A standard data model with objects, literals, types, etc.
    *   **Object Definition Language (ODL):** Used to define the database schema.
    *   **Object Query Language (OQL):** A declarative query language for objects.
    *   **Bindings:** To programming languages like C++, Java, and Smalltalk.
---
#### 3. Object Definition Language (ODL)
ODL is the schema definition language for OODBMS, analogous to SQL's DDL (CREATE TABLE...).
*   It defines classes, their attributes, relationships, and methods.
*   **Example:**
    ```odl
    interface Person {
      attribute string name;
      attribute Date birthdate;
      relationship Set<Project> works_on inverse Project::has_members;
    };
    interface Project {
      attribute string title;
      relationship Set<Person> has_members inverse Person::works_on;
    };
    ```
---
#### 4. Object Query Language (OQL)
OQL is a query language for OODBMS, designed to be similar to SQL but for objects.
*   It supports complex objects, path expressions, and inheritance.
*   **Example:** `SELECT p.name FROM Persons p WHERE p.age > 30`

#### 5. Object Database Conceptual Design
The process involves mapping an object-oriented model (e.g., from UML) directly to an OODB schema.
*   **Mapping Classes:** Each persistent class becomes a class in the OODB schema.
*   **Mapping Attributes:** Simple attributes are mapped directly.
*   **Mapping Relationships:** Relationships (like 1:N, M:N) are mapped using reference attributes or relationship constructs (as shown in the ODL example).
---
#### 6. Distributed Database Concepts
A **Distributed Database (DDB)** is a collection of multiple, logically interrelated databases distributed over a computer network.
*   **Motivation:** Modular growth, improved performance/availability, and organizational autonomy.

#### 7. Data Fragmentation, Replication, and Allocation
These are the core design techniques for distributing data.
*   **Fragmentation:** Splitting a relation (table) into smaller pieces.
    *   **Horizontal:** A subset of *rows* (e.g., all customers in Europe).
    *   **Vertical:** A subset of *columns* (e.g., customer contact info separate from order history).
*   **Replication:** Storing multiple copies of a fragment at different sites.
    *   Improves reliability and read performance but complicates updates.
*   **Allocation:** Deciding at which site(s) to place each fragment.
---
#### 8. Types of Distributed Database Systems
*   **Homogeneous DDBMS:** All sites use the same DBMS software.
*   **Heterogeneous DDBMS:** Different sites may run different DBMS software (much more complex, requires gateways).

#### 9. Query Processing in Distributed Databases
The goal is to transform a high-level query into an efficient execution strategy across the network.
*   **Key Steps:**
    1.  **Query Decomposition:** Parse and validate the query.
    2.  **Data Localization:** Translate the query into fragments (e.g., replace a global table name with its constituent fragments).
    3.  **Global Query Optimization:** Find the best (least cost) execution plan, considering local processing cost and network communication cost (which is often the dominant factor). Techniques include **semijoin** to reduce data transfer.
---
#### 10. Overview of Concurrency Control and Recovery in Distributed Databases
*   **Concurrency Control:** Ensures transaction isolation and consistency in a distributed environment.
    *   **Distributed Locking:** Protocols like *Distributed Two-Phase Locking (2PL)*.
    *   **Timestamp Ordering:** Assigns unique timestamps to order transactions globally.
    *   **Distributed Deadlock Detection:** More complex as waits-for graphs are distributed.
*   **Recvery:** Ensures atomicity and durability even after failures.
    *   **Distributed Commit:** The **Two-Phase Commit (2PC)** protocol is the standard for ensuring all sites either all commit or all abort a transaction. It involves a coordinator and participants.
    *   **Logging & Checkpointing:** Similar to centralized DBMS, but logs are maintained at each local site.

